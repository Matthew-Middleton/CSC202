/**Solves an nQueens game.
 * Algorithm: Take in the size of the board. Make boards with different combinations to check if the 
 * If the number of the queens on a board is equal to the size of the board return true. Once that is done, iterate over
 * the boards to check which is and is not a solution.
 * Complexity: O(n!*2)
 */
package queensBoard;
import math.Factorial;

public class NQueens
{
	private int size;
	private int attack[];
	private String qBoard[][];
	private Object queenie[];
	private Factorial fact = new Factorial();
	int s = 0;
	
	public NQueens()
	{
		
	}
	
	public NQueens(int n)
	{
		this.size = n;
	}
	/**Prints the board with the locations of each possible location for a queen
	 * @param attack
	 */
	//think about putting all of the checked values into an array and then check over that array
	public void printEm(int attack[])
	{
		System.out.println("Solution " + (++s));
		for(int i=0; i<size; i++)
		{
			for(int j=0; j<size; j++)//if using solveEm() set j=1 and j<=size
				{
					if(attack[i]==j)
						System.out.print(" Q ");
					else
						System.out.print(" - ");
				}
			System.out.println();
		}
		System.out.println();
	}
	/**Creates a board out of the queen possibilities
	 * @param attack
	 */
	public void creatBoardPoss(int attack[])
	{
		qBoard = new String[size][size];
		for(int i=0; i<size; i++)
			for(int j=0; j<size; j++)
			{
				if(attack[i]==j)
					qBoard[i][j] = "Q";
				else
					qBoard[i][j] = "-";
			}
		queenie = new Object[fact.recFact(size)*2];
		for(int i=0; i<fact.recFact(size)*2; i++)
			queenie[i] = qBoard;
	}
	/**Checks if the point is safe
	 * @param i
	 * @param attack
	 * @return
	 */
	public boolean checkSafety(int i, int attack[])
	{
		for(int j=1; j<i; j++)
		{
			// same column
			 if (attack[j]==attack[i])
				return false;
			 //diagonally down
	         if (attack[j]-attack[i]==j-i)
	            return false;
	         //diagonally up
	         if (attack[i]-attack[j]==i-j)
	        	return false;
		}
		return true;
	}
	/**Checks if the points on the board are attacked
	 * @param y
	 * @return
	 */
	public boolean unsafe(int y)
	{
		int x = attack[y];
		for(int i=1; i<=y; i++)
		{
			int t = attack[y-i];
			if(t==x||t==x-i||t==x+i)//checks other points to see if they are unsafe
				return true;
		}
		return false;
	}
	/**Implements the iterative/recursive method that solves for the nQueens problem
	 */
	public void nQueensSolve()
	{
		attack = new int[size];
		nQueensSolveRec(0,attack);
		//nQueensIter(0,attack);
	}
	/**Sorts through and prints all possible combinations of nQueens
	 */
	public void nQueensSolveRec(int i, int attack[])
	{
		if(i==size)
			printEm(attack);//for printing all the possible solutions; takes time as the size increases due to n!
			//;
		else
			for(int q=0; q<size; q++)
			{
				//put in a backtracking check or a board check
				attack[i] = q;
				if(attack[i]<size&&checkSafety(i,attack)==true)
					nQueensSolveRec(i+1,attack);
			}
	}
	/**Solves the nQueens problem
	 * iterative solution
	 * @param i
	 * @param attack
	 */
	public void nQueensIter(int i, int attack[])
	{
		i = 0;
		attack[0] = -1;
		while(i>=0)
		{
			do
			{
				attack[i]++;//advances the point on the board
			}while(attack[i]<size&&unsafe(i));//checks if within bounds and each piece is safe
			if(attack[i]<size)
			{
				if(i<size-1)
					attack[++i] = -1;//sets the queen on the spot
				else
					printEm(attack);
			}
			else
				i--;
		}
	}
	/*Sets the size for an n-sized board
	 */
	public void setSize(int n)
	{
		this.size = n;
	}
	/*Returns the size for an n-sized board
	 */
	public int getSize()
	{
		return size;
	}
	/*Returns the board that shows the queens attack paths
	 */
	public int[] getAttack()
	{
		return attack;
	}
}

