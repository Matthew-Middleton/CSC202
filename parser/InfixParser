/********************************************************************************************************************************\
 * Purpose: To convert an in-fix expression to a post-fix expression
 * Algorithm: Take an expression and remove any whitespace. Create an empty stack for operators and an empty list or an equivalent
 * data structure for the post-fix expression. Iterate over the expression and push any operators on the stack. If it is a beginning
 * parenthesis, push it on to the stack. If it is a ending parenthesis pop the stack until a beginning parenthesis is found.
 * Establish a hierarchy for the operators. If any operators remain on the stack at the end append them to the end of the stack.
 */
package parser;
import java.util.LinkedList;
import java.util.regex.Pattern;
import java.util.Stack;

public class InfixParser
{
	private LinkedList<String> list = new LinkedList<String>();
	private Stack<String> opStack = new Stack<String>();
	private Stack<String> stack = new Stack<String>();
	private Pattern number = Pattern.compile("[0-9]");
	private String expression, op;
	/**Constructor
	 */
	public InfixParser()
	{
		
	}
	/**Constructor
	 * @param expression
	 */
	public InfixParser(String expression)
	{
		this.expression = removeWhiteSpace(expression);
	}
	/**Implements rearrangeExpression()
	 */
	public LinkedList<String> parse()
	{
		stack.clear();
		return parse(expression);
	}
	/**Iteratively sorts the list from in-fix to post-fix
	 * @param i
	 * @param list
	 * @return
	 */
	//not finished
	public LinkedList<String> parse(String expression)
	{
		for(int i=0; i<expression.length(); i++)
		{
			if(number.matcher(expression.substring(i, i+1)).matches())
				list.add(expression.substring(i, i+1));
			else if(expression.substring(i, i+1)=="(")
				opStack.push(expression.substring(i, i+1));
			else if(expression.substring(i, i+1)==")")
			{
				op = opStack.pop();
				while(op!="(")
				{
					list.add(op);
					op = opStack.pop();
				}
			}
			else
			{
				while(opStack.empty()==false&&hierarchy(opStack.peek())>=hierarchy(expression.substring(i, i+1)))
					list.add(opStack.pop());
				opStack.push(expression.substring(i, i+1));
			}
		}
		while(opStack.empty()==false)
			list.add(opStack.pop());
		return list;
	}
	/**Checks if the expression is balanced for parentheses
	 * @param list
	 * @return
	 */
	public boolean isBalanced(String expression)
	{
		for(int i=0; i<expression.length(); i++)
		{
			if(expression.substring(i, i+1)=="(")
				stack.push(expression.substring(i, i+1));
			if(expression.substring(i, i+1)==")")
			{
				if(stack.isEmpty())
					return false;
				else if(matchingPair(stack.pop(), expression.substring(i, i+1)))
					return false;
			}
		}
		if(stack.isEmpty())
			return true;
		else
			return false;
	}
	/**Takes two operators and determines if they are a pair
	 * @param op1
	 * @param op2
	 * @return
	 */
	public boolean matchingPair(String op1, String op2)
	{
		if(op1=="("&&op2==")")
			return true;
		else
			return false;
	}
	/**Establishes a hierarchy based on the type of operator
	 * the greater the precedence of the operator the higher the number returned
	 * @param i
	 * @param list
	 * @return
	 */
	public int hierarchy(String op)
	{
		if(op=="*"||op=="/")
			return 2;
		if(op=="+"||op=="-")
			return 1;
		if(op=="(")
			return 3;
		else
			return 0;
	}
	/**Removes any white space from an expression
	 * @param expression
	 * @return
	 */
	public String removeWhiteSpace(String expression)
	{
		return expression.replaceAll("\\s", "");
	}
	/**Sets the mathematical expression
	 * @param expression
	 */
	public void setExpression(String expression)
	{
		this.expression = expression;
	}
	/**Returns the mathematical expression
	 * @return
	 */
	public String getExpression()
	{
		return expression;
	}
}
