/********************************************************************************************************************************\
 * Purpose: To convert an in-fix expression to a post-fix expression
 * Algorithm: Take an expression and remove any whitespace. Create an empty stack for operators and an empty list or an equivalent
 * data structure for the post-fix expression. Iterate over the expression and push any operators on the stack. If it is a beginning
 * parenthesis, push it on to the stack. If it is a ending parenthesis pop the stack until a beginning parenthesis is found.
 * Establish a hierarchy for the operators. If any operators remain on the stack at the end append them to the end of the stack.
 */
package parser;
import java.util.LinkedList;
import java.util.regex.Pattern;
import java.util.Stack;
import java.util.HashMap;

public class InfixParser
{
	private LinkedList<String> list = new LinkedList<String>();
	private Stack<String> opStack = new Stack<String>();
	private Stack<String> stack = new Stack<String>();
	private Pattern number = Pattern.compile("[0-9]");
	private HashMap<String, Integer> hierarchy = new HashMap<String, Integer>();
	private String expression, op;
	/**Constructor
	 */
	public InfixParser()
	{
		
	}
	/**Constructor
	 * @param expression
	 */
	public InfixParser(String expression)
	{
		this.expression = removeWhiteSpace(expression);
	}
	/**Implements rearrangeExpression()
	 */
	public LinkedList<String> parse()
	{
		stack.clear();
		return parse(expression);
	}
	/**Iteratively sorts the list from in-fix to post-fix
	 * @param i
	 * @param list
	 * @return
	 */
	//not finished
	public LinkedList<String> parse(String expression)
	{
		setHierarchy();
		String expressArr[] = toArray(expression);
		for(String inst: expressArr)
		{
			if(number.matcher(inst).matches()==true)
				list.add(inst);
			else if(inst=="(")
				opStack.push(inst);
			else if(inst==")")
			{
				op = opStack.pop();
				while(op!="(")
				{
					list.add(op);
					op = opStack.pop();
				}
			}
			else
			{
				while(opStack.empty()==false&&hierarchy(opStack.peek())>=hierarchy(inst))
					list.add(opStack.pop());
				opStack.push(inst);
			}
		}
		while(opStack.isEmpty()!=true)
			list.add(opStack.pop());
		return list;
	}
	/**Checks if the expression is balanced for parentheses
	 * @param list
	 * @return
	 */
	//need to tweak to accurately work
	public boolean isBalanced(String expression)
	{
		for(int i=0; i<expression.length(); i++)
		{
			if(expression.substring(i, i+1)=="(")
				stack.push(expression.substring(i, i+1));
			if(expression.substring(i, i+1)==")")
			{
				if(stack.isEmpty())
					return true;
				else if(matchingPair(stack.pop(), expression.substring(i, i+1)))
					return true;
			}
		}
		if(stack.isEmpty())
			return true;
		else
			return false;
	}
	/**Takes two operators and determines if they are a pair
	 * @param op1
	 * @param op2
	 * @return
	 */
	public boolean matchingPair(String op1, String op2)
	{
		if(op1=="("&&op2==")")
			return true;
		else
			return false;
	}
	/**Establishes a hierarchy based on the type of operator
	 * the greater the precedence of the operator the higher the number returned
	 * @param i
	 * @param list
	 * @return
	 */
	private void setHierarchy()
	{
		hierarchy.put("(", 1);
		hierarchy.put(")", 1);
		hierarchy.put("-", 2);
		hierarchy.put("+", 2);
		hierarchy.put("*", 3);
		hierarchy.put("/", 3);
	}
	/**Returns the value associated with the key that was given
	* @param op
	*/
	public Integer hierarchy(String op)
	{
		return hierarchy.get(op);
	}
	
	private String[] toArray(String expression)
	{
		String expressArr[] = new String[expression.length()];
		for(int i=0; i<expressArr.length; i++)
		{
			expressArr[i] = expression.substring(i, i+1);
		}
		return expressArr;
	}
	/**Removes any white space from an expression
	 * @param expression
	 * @return
	 */
	public String removeWhiteSpace(String expression)
	{
		return expression.replaceAll("\\s", "");
	}
	/**Sets the mathematical expression
	 * @param expression
	 */
	public void setExpression(String expression)
	{
		this.expression = expression;
	}
	/**Returns the mathematical expression
	 * @return
	 */
	public String getExpression()
	{
		return expression;
	}
}
