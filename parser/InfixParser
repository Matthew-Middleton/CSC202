/********************************************************************************************************************************\
 * Purpose: To convert an in-fix expression to a post-fix expression
 * Algorithm: Take an expression and remove any whitespace. Then, juxtapose the position of the numbers and the operators so that
 * changes from number operator number to reading as number number operator. Treat any other operator using the PEMDAS standard.
 * "Separate" the linked list by groups of three and switch the second and third positions
 */
package parser;
import java.util.LinkedList;
import java.util.regex.Pattern;
import java.util.Stack;

public class InfixParser
{
	private LinkedList<String> list = new LinkedList<String>();
	private LinkedList<String> outList = new LinkedList<String>();
	private Stack<String> opStack = new Stack<String>();
	private Stack<String> stack = new Stack<String>();
	private Pattern operator = Pattern.compile("[\\+.\\-.\\*.\\/.]");
	private Pattern number = Pattern.compile("[0-9]");
	private String expression, op;
	/**Constructor
	 */
	public InfixParser()
	{
		
	}
	/**Constructor
	 * @param expression
	 */
	public InfixParser(String expression)
	{
		this.expression = removeWhiteSpace(expression);
	}
	/**Implements rearrangeExpression()
	 */
	public LinkedList<String> parse()
	{
		stack.clear();
		return parse(0, expression, outList, opStack);
	}
	/**Recursively sorts the list from in-fix to post-fix
	 * @param i
	 * @param list
	 * @return
	 */
	//not finished
	public LinkedList<String> parse(int i, String expression, LinkedList<String> outList, Stack<String> opStack)
	{
		if(i>=expression.length())
			return outList;
		else
		{
			if(expression.substring(i, i+1)=="(")
			{
				opStack.push(expression.substring(i, i+1));
				return parse(i+1, expression, outList, opStack);
			}
			if(expression.substring(i, i+1)==")")
			{
				int p = 0;
				do
				{
					opStack.pop();
					p--;
				}while(opStack.get(p)!="(");
			}
			if(number.matcher(expression.substring(i, i+1)).matches())
			{
				outList.add(expression.substring(i, i+1));
				return parse(i+1, expression, outList, opStack);
			}
			if(operator.matcher(expression.substring(i,i+1)).matches())
			{
				if(opStack.empty()==false)
					outList.add(opStack.pop());
				opStack.push(expression.substring(i, i+1));
				return parse(i+1, expression, outList, opStack);
			}
			outList.add(opStack.pop());
			return parse(i+1, expression, outList, opStack);
		}
	}
	/**Recursively sorts the linked list by switching the index
	 * @param i
	 * @param list
	 * @return
	 */
	//not finished
	public LinkedList<String> parse(int i, LinkedList<String> list)
	{
		if(i>=list.size())
			return list;//beginnings of the same project for switching around index
		else
		{
			//must expand past first set of operators
			if(number.matcher(list.get(i)).matches()==false)
				return parse(i+1, list);
			if(list.get(i)=="(")
				pairSwitch(i, list);
			op = list.get(i+1);
			list.remove(op);
			list.add(i+2, op);
			return parse(i+2, list);
		}
	}
	/**Finds a pair of parenthesis and takes the operator that occurred before the first parenthesis
	 * and switches it with the latter parenthesis
	 * @param i
	 * @param list
	 */
	public void pairSwitch(int i, LinkedList<String> list)
	{
		stack.clear();
		for(int j=i; j<list.size(); j++)
		{
			//index of the array is the index of the parenthesis in the expression
			if(list.get(i)=="(")
				stack.push(list.get(i));
			if(list.get(j)==")")
				if(matchingPair(stack.pop(), list.get(j))==true)
				{
					op = list.get(i-1);
					list.remove(op);
					list.remove(j);
					list.add(j, op);
				}
		}
	}
	/**Checks if the expression is balanced for parentheses
	 * @param list
	 * @return
	 */
	public boolean isBalanced(String expression)
	{
		for(int i=0; i<expression.length(); i++)
		{
			if(expression.substring(i, i+1)=="(")
				stack.push(expression.substring(i, i+1));
			if(expression.substring(i, i+1)==")")
			{
				if(stack.isEmpty())
					return false;
				else if(matchingPair(stack.pop(), expression.substring(i, i+1)))
					return false;
			}
		}
		if(stack.isEmpty())
			return true;
		else
			return false;
	}
	/**Takes two operators and determines if they are a pair
	 * @param op1
	 * @param op2
	 * @return
	 */
	public boolean matchingPair(String op1, String op2)
	{
		if(op1=="("&&op2==")")
			return true;
		else
			return false;
	}
	/**Establishes a hierarchy based on the type of operator
	 * the greater the precedence of the operator the higher the number returned
	 * @param i
	 * @param list
	 * @return
	 */
	public int hierarchy(int i, LinkedList<String> opStack)
	{
		if(opStack.get(i)=="*"||opStack.get(i)=="/")
			return 2;
		if(opStack.get(i)=="+"||opStack.get(i)=="-")
			return 1;
		else
			return 1;
	}
	/**Removes any white space from an expression
	 * @param expression
	 * @return
	 */
	public String removeWhiteSpace(String expression)
	{
		return expression.replaceAll("\\s", "");
	}
	/**Creates a linked list from a mathematical expression
	 * @param expression
	 * @return
	 */
	public LinkedList<String> createList(String expression)
	{
		
		for(int i=0; i<expression.length(); i++)
			list.add(expression.substring(i, i+1));
		return list;
	}
	/**Sets the mathematical expression
	 * @param expression
	 */
	public void setExpression(String expression)
	{
		this.expression = expression;
	}
	/**Returns the mathematical expression
	 * @return
	 */
	public String getExpression()
	{
		return expression;
	}
}
